use crate::diagnostic::Emitter;
use crate::llir::{ArgEncoding, AcceleratingByteMask};
use crate::parse::lalrparser_util as util;

grammar<'st>(emitter: &'st dyn Emitter);

extern {
    type Error = std::num::ParseIntError;
}

pub Abi = <Token*>;

Token: ArgEncoding = {
    "S" => ArgEncoding::Dword,
    "s" => ArgEncoding::Word,
    "C" => ArgEncoding::Color,
    "o" => ArgEncoding::JumpOffset,
    "t" => ArgEncoding::JumpTime,
    "f" => ArgEncoding::Float,
    "_" => ArgEncoding::Padding,
    "n" => ArgEncoding::Sprite,
    "N" => ArgEncoding::Script,
    ZString,
    MString,
};

ZString: ArgEncoding = {
    "z" "(" <block_size:BlockSizeArg> ")"
    => ArgEncoding::String {
        block_size: block_size as _,
        mask: AcceleratingByteMask::constant(0x00),
    },

    "z" => {
        emitter.as_sized().emit(warning!(
            "'z' without arguments is deprecated; please write 'z(bs=4)'",
        )).ignore();

        let mask = AcceleratingByteMask::constant(0x00);
        ArgEncoding::String { block_size: 4, mask }
    },
};

MString: ArgEncoding = {
    "m" "(" <block_size:BlockSizeArg> ";" <mask:MaskArg> ")"
    => ArgEncoding::String { block_size: block_size as _, mask },

    "m" => {
        emitter.as_sized().emit(warning!(
            "'m' without arguments is deprecated; please write 'm(bs=4;mask=0x77,0,0)'",
        )).ignore();

        let mask = AcceleratingByteMask::constant(0x77);
        ArgEncoding::String { block_size: 4, mask }
    },
};

BlockSizeArg = "bs" "=" <UnsignedInt>;

MaskArg: AcceleratingByteMask = {
    "mask" "=" <mask:UnsignedInt> "," <vel:UnsignedInt> "," <accel:UnsignedInt>
    => AcceleratingByteMask { mask: mask as u8, vel: vel as u8, accel: accel as u8 }
};

UnsignedInt: u32 = {
    <s:r"[0-9]+"> =>? {
        #![allow(unused_braces)]  // without these braces, lalrpop can't parse this turbofish
        util::parse_ascii::<_, u32>(s).map_err(Into::into)
    },
    <s:r"0[xX][0-9a-fA-F]+"> =>? util::u32_from_ascii_radix(&s[2..], 16).map_err(Into::into),
    <s:r"0[bB][0-1]+"> =>? util::u32_from_ascii_radix(&s[2..], 2).map_err(Into::into),
};
