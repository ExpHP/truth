use crate::diagnostic::Diagnostic;
use crate::context::defs::{AutoConstKind, TypeColor};
use crate::llir::{ArgEncoding, AcceleratingByteMask, TimelineArgKind, StringArgSize};
use crate::parse::lalrparser_util as util;

grammar<'st>(diagnostics: &mut Vec<Diagnostic>);

extern {
    // we put our actual error payload in the vec alongside warnings,
    // but we can't display LALRPOP's own errors unless this thing impls display
    type Error = util::PanicDisplay;
}

pub(crate) Abi = <ArgEncoding*>;

ArgEncoding: ArgEncoding = {
    "S" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 4, ty_color },
    "s" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 2, ty_color },
    // FIXME: these two should be unsigned
    "U" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 4, ty_color },
    "u" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 2, ty_color },
    "C" => ArgEncoding::Color,
    "o" => ArgEncoding::JumpOffset,
    "t" => ArgEncoding::JumpTime,
    "f" => ArgEncoding::Float,
    "_" => ArgEncoding::Padding,
    "n" => ArgEncoding::Integer { size: 4, ty_color: Some(AutoConstKind::AnmSprite.into()) },
    "N" => ArgEncoding::Integer { size: 4, ty_color: Some(AutoConstKind::AnmScript.into()) },
    "E" => ArgEncoding::Integer { size: 4, ty_color: Some(AutoConstKind::EclSub.into()) },
    ZString,
    MString,
    TArg,
};

OptionalEnum: Option<TypeColor> = {
    "(" "enum" "=" <name:StringLiteral> ")" =>? {
        name.parse().map_err(|e| { diagnostics.push(error!("{}", e)); util::PanicDisplay.into() })
            .map(|ident| Some(TypeColor::Enum(ident)))
    },
    => None,
};

ZString: ArgEncoding = {
    "z" "(" <size:StringArgSize> ")"
    => {
        let mask = AcceleratingByteMask::constant(0x00);
        ArgEncoding::String { size, mask, furibug: false }
    },

    "z" => {
        diagnostics.push(warning!(
            "'z' without arguments is deprecated; please write 'z(bs=4)'",
        ));

        let mask = AcceleratingByteMask::constant(0x00);
        let size = StringArgSize::Block { block_size: 4 };
        ArgEncoding::String { size, mask, furibug: false }
    },
};

MString: ArgEncoding = {
    "m" "(" <size:StringArgSize> ";" <mask:MaskArg> <furibug:(";" "furibug")?> ")"
    => ArgEncoding::String { size, mask, furibug: furibug.is_some() },

    "m" => {
        diagnostics.push(warning!(
            "'m' without arguments is deprecated; please write 'm(bs=4;mask=0x77,0,0)'",
        ));

        let mask = AcceleratingByteMask::constant(0x77);
        let size = StringArgSize::Block { block_size: 4 };
        ArgEncoding::String { size, mask, furibug: false }
    },
};

#[inline]
StringArgSize: StringArgSize = {
    "len" "=" <len:UnsignedInt> <nulless:(";" "nulless")?> => StringArgSize::Fixed {
        len: len as _,
        nulless: nulless.is_some(),
    },
    "bs" "=" <x:UnsignedInt> => StringArgSize::Block { block_size: x as _ },
};

MaskArg: AcceleratingByteMask = {
    "mask" "=" <mask:UnsignedInt> "," <vel:UnsignedInt> "," <accel:UnsignedInt>
    => AcceleratingByteMask { mask: mask as u8, vel: vel as u8, accel: accel as u8 }
};

TArg: ArgEncoding = {
    "T" "(" "m" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Enum(AutoConstKind::MsgSub.into())),
    "T" "(" "e" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Enum(AutoConstKind::EclSub.into())),
    "T" "(" "s" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Word),
    "T" "(" "u" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Word),
    "T" "(" "_" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Unused),
};

UnsignedInt: u32 = {
    <s:r"[0-9]+"> =>? {
        #![allow(unused_braces)]  // without these braces, lalrpop can't parse this turbofish
        util::parse_ascii::<_, u32>(s).map_err(|e| { diagnostics.push(error!("{}", e)); util::PanicDisplay.into() })
    },
    <s:r"0[xX][0-9a-fA-F]+"> =>? util::u32_from_ascii_radix(&s[2..], 16).map_err(|e| { diagnostics.push(error!("{}", e)); util::PanicDisplay.into() }),
    <s:r"0[bB][0-1]+"> =>? util::u32_from_ascii_radix(&s[2..], 2).map_err(|e| { diagnostics.push(error!("{}", e)); util::PanicDisplay.into() }),
};

StringLiteral: String = {
    <l:@L> <s:r##""([^\\"]|\\.)*""##> <r:@R> =>? {
        util::parse_string_literal(s).map_err(|e| { diagnostics.push(e); util::PanicDisplay.into() })
    },
};
