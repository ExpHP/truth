use crate::ident::Ident;
use crate::diagnostic::Diagnostic;
use crate::context::defs::{TypeColor, auto_enum_names};
use crate::llir::{ArgEncoding, AcceleratingByteMask, TimelineArgKind, StringArgSize};
use crate::parse::lalrparser_util as util;

grammar<'st>(diagnostics: &mut Vec<Diagnostic>);

extern {
    // we put our actual error payload in the vec alongside warnings,
    // but we can't display LALRPOP's own errors unless this thing impls display
    type Error = util::PanicDisplay;
}

pub(crate) Abi = <ArgEncoding*>;

ArgEncoding: ArgEncoding = {
    "S" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 4, ty_color },
    "s" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 2, ty_color },
    // FIXME: these two should be unsigned
    "U" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 4, ty_color },
    "u" <ty_color:OptionalEnum> => ArgEncoding::Integer { size: 2, ty_color },
    "C" => ArgEncoding::Color,
    "o" => ArgEncoding::JumpOffset,
    "t" => ArgEncoding::JumpTime,
    "f" => ArgEncoding::Float,
    "_" => ArgEncoding::Padding,
    "n" => ArgEncoding::Integer { size: 4, ty_color: Some(TypeColor::Enum(auto_enum_names::anm_sprite())) },
    "N" => ArgEncoding::Integer { size: 4, ty_color: Some(TypeColor::Enum(auto_enum_names::anm_script())) },
    "E" => ArgEncoding::Integer { size: 4, ty_color: Some(TypeColor::Enum(auto_enum_names::ecl_sub())) },
    ZString,
    MString,
    TArg,
};

OptionalEnum: Option<TypeColor> = {
    "(" "enum" "=" <name:LitString> ")" =>? {
        Ident::new_user(&name).map_err(|e| { diagnostics.push(error!("{}", e)); util::PanicDisplay.into() })
            .map(|ident| Some(TypeColor::Enum(ident)))
    },
    => None,
};

ZString: ArgEncoding = {
    "z" "(" <size:StringArgSize> ")"
    => {
        let mask = AcceleratingByteMask::constant(0x00);
        ArgEncoding::String { size, mask, furibug: false }
    },

    "z" => {
        diagnostics.push(warning!(
            "'z' without arguments is deprecated; please write 'z(bs=4)'",
        ));

        let mask = AcceleratingByteMask::constant(0x00);
        let size = StringArgSize::Block { block_size: 4 };
        ArgEncoding::String { size, mask, furibug: false }
    },
};

MString: ArgEncoding = {
    "m" "(" <size:StringArgSize> ";" <mask:MaskArg> <furibug:(";" "furibug")?> ")"
    => ArgEncoding::String { size, mask, furibug: furibug.is_some() },

    "m" => {
        diagnostics.push(warning!(
            "'m' without arguments is deprecated; please write 'm(bs=4;mask=0x77,0,0)'",
        ));

        let mask = AcceleratingByteMask::constant(0x77);
        let size = StringArgSize::Block { block_size: 4 };
        ArgEncoding::String { size, mask, furibug: false }
    },
};

#[inline]
StringArgSize: StringArgSize = {
    "len" "=" <len:LitIntUnsigned> <nulless:(";" "nulless")?> => StringArgSize::Fixed {
        len: len as _,
        nulless: nulless.is_some(),
    },
    "bs" "=" <x:LitIntUnsigned> => StringArgSize::Block { block_size: x as _ },
};

MaskArg: AcceleratingByteMask = {
    "mask" "=" <mask:LitIntUnsigned> "," <vel:LitIntUnsigned> "," <accel:LitIntUnsigned>
    => AcceleratingByteMask { mask: mask as u8, vel: vel as u8, accel: accel as u8 }
};

TArg: ArgEncoding = {
    "T" "(" "m" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Enum(TypeColor::Enum(auto_enum_names::msg_script()))),
    "T" "(" "e" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Enum(TypeColor::Enum(auto_enum_names::ecl_sub()))),
    "T" "(" "s" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Word),
    "T" "(" "u" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Word),
    "T" "(" "_" ")" => ArgEncoding::TimelineArg(TimelineArgKind::Unused),
};

LitIntUnsigned: u32 = {
    <l: @L> <text:r##"[0-9]+|0[xX][0-9a-fA-F]+|0[bB][0-1]+"##> <r: @R> =>? {
        util::parse_u32_literal_nospan(text)
            .map_err(|e| { diagnostics.push(e); util::PanicDisplay.into() })
    },
};

LitString: String = {
    <l:@L> <s:r##""([^\\"]|\\.)*""##> <r:@R> =>? {
        util::parse_string_literal_nospan(s)
            .map_err(|e| { diagnostics.push(e); util::PanicDisplay.into() })
    },
};
