use lalrpop_util::ParseError;
use bstr::{BStr, ByteSlice};
use crate::parse::lexer::{Token};
use crate::meta::{self, Meta};
use crate::ident::Ident;
use crate::pos::{Sp, BytePos};
use crate::ast::{
    self,
    Script, MetaKeyword,
    Item, FuncKeyword, FuncReturnType, FileListKeyword, AssignOpKind,
    Stmt, StmtBody, StmtGoto, StmtLabel, CondKeyword, CondBlock, Cond, Block,
    Expr, BinopKind, UnopKind, Var, VarDeclKeyword, VarReadType, LitString,
    DifficultyLabel,
};
use crate::var::VarId;
use super::lalrparser_util::{parse_ascii, u32_from_ascii_radix, push};

grammar<'input, 'st>(state: &'st mut crate::parse::State);

extern {
    type Location = BytePos;
    type Error = crate::parse::ErrorPayload;

    enum Token<'input> {
        // Terminals
        STRING => Token::LitString(<&'input BStr>),
        FLOAT => Token::LitFloat(<&'input BStr>),
        FLOAT_RAD => Token::LitRad(<&'input BStr>),
        INT => Token::LitIntDec(<&'input BStr>),
        INT_HEX => Token::LitIntHex(<&'input BStr>),
        INT_BIN => Token::LitIntBin(<&'input BStr>),
        DIFFICULTY => Token::Difficulty(<&'input BStr>),
        IDENT => Token::Ident(<&'input BStr>),
        "," => Token::Comma,
        "?" => Token::Question,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "[" => Token::BracketOpen,
        "]" => Token::BracketClose,
        "{" => Token::BraceOpen,
        "}" => Token::BraceClose,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "@" => Token::AtSign,
        "..." => Token::Ellipsis,
        "." => Token::Dot,
        "=" => Token::Eq,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "^" => Token::Caret,
        "|" => Token::Or,
        "&" => Token::And,
        "+=" => Token::PlusEq,
        "-=" => Token::MinusEq,
        "*=" => Token::StarEq,
        "/=" => Token::SlashEq,
        "%=" => Token::PercentEq,
        "^=" => Token::CaretEq,
        "|=" => Token::OrEq,
        "&=" => Token::AndEq,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "<" => Token::Less,
        "<=" => Token::LessEq,
        ">" => Token::Greater,
        ">=" => Token::GreaterEq,
        "!" => Token::Not,
        "||" => Token::OrOr,
        "&&" => Token::AndAnd,
        "--" => Token::MinusMinus,
        "$" => Token::Cash,
        "#" => Token::Hash,
        "anim" => Token::Anim,
        "ecli" => Token::Ecli,
        "meta" => Token::Meta,
        "sub" => Token::Sub,
        "timeline" => Token::Timeline,
        "script" => Token::Script,
        "entry" => Token::Entry,
        "var" => Token::Var,
        "int" => Token::Int,
        "float" => Token::Float,
        "void" => Token::Void,
        "inline" => Token::Inline,
        "insdef" => Token::Insdef,
        "return" => Token::Return,
        "goto" => Token::Goto,
        "loop" => Token::Loop,
        "if" => Token::If,
        "else" => Token::Else,
        "unless" => Token::Unless,
        "do" => Token::Do,
        "while" => Token::While,
        "times" => Token::Times,
        "break" => Token::Break,
        "switch" => Token::Switch,
        "case" => Token::Case,
        "default" => Token::Default,
        "interrupt" => Token::Interrupt,
        "async" => Token::Async,
        "global" => Token::Global,
        "false" => Token::False,
        "true" => Token::True,
        "pragma" => Token::Pragma,
        "mapfile" => Token::Mapfile,
        "sin" => Token::Sin,
        "cos" => Token::Cos,
        "sqrt" => Token::Sqrt,
        "_S" => Token::CastI,
        "_f" => Token::CastF,
        // Virtual tokens for parsable nonterminals
        Dispatch_Script => Token::VirtualDispatch(crate::parse::AnythingTag::Script),
        Dispatch_Item => Token::VirtualDispatch(crate::parse::AnythingTag::Item),
        Dispatch_Block => Token::VirtualDispatch(crate::parse::AnythingTag::Block),
        Dispatch_Stmt => Token::VirtualDispatch(crate::parse::AnythingTag::Stmt),
        Dispatch_Expr => Token::VirtualDispatch(crate::parse::AnythingTag::Expr),
        Dispatch_Var => Token::VirtualDispatch(crate::parse::AnythingTag::Var),
        Dispatch_LitString => Token::VirtualDispatch(crate::parse::AnythingTag::LitString),
        Dispatch_Meta => Token::VirtualDispatch(crate::parse::AnythingTag::Meta),
    }
}

// =================================================
// Parser dispatch

/// The parser's "designated driver."
///
/// Each nonterminal marked 'pub' in a lalrpop file generates an independent parser,
/// and the code sharing between them is inefficient. Thus, one can reduce compile
/// times a pretty fair deal by only having one public parser, which dispatches
/// to other nonterminals based on a virtual token inserted by the caller at
/// the beginning of the token stream.
///
/// Don't use this directly; use the [`crate::parse::Parse`] trait, which takes
/// care of all the silly virtual dispatch business.
pub(crate) Anything: Sp<crate::parse::AnythingValue> = Sp<AnythingInner>;

AnythingInner: crate::parse::AnythingValue = {
    Dispatch_Script <x:Script> => crate::parse::AnythingValue::Script(x),
    Dispatch_Item <x:Item> => crate::parse::AnythingValue::Item(x),
    Dispatch_Block <x:Block> => crate::parse::AnythingValue::Block(x),
    Dispatch_Stmt <x:Stmt> => crate::parse::AnythingValue::Stmt(x),
    Dispatch_Expr <x:Expr> => crate::parse::AnythingValue::Expr(x),
    Dispatch_Var <x:Var> => crate::parse::AnythingValue::Var(x),
    Dispatch_LitString <x:LitString> => crate::parse::AnythingValue::LitString(x),
    Dispatch_Meta <x:Meta> => crate::parse::AnythingValue::Meta(x),
};

// =================================================
// Items

Script: Script = {
    <items:Items> => {
        let mapfiles = state.mapfiles.clone();
        Script { items, mapfiles }
    },
};

Items: Vec<Sp<Item>> = {
    => vec![],

    <items:Items> <item:Sp<Item>> => push(items, item),

    // FIXME: this syntax likely won't stay.  People might be confused that it is treated
    //        in a declarative manner, and I don't know what I want our preprocessing solution
    //        to look like
    <items:Items> "#" "pragma" "mapfile" <file:Sp<LitString>> => {
        state.mapfiles.push(file);
        items
    },
};

Item: Item = {
    <inline:"inline"?> <keyword:FuncKeyword> <name:Ident>
        "(" <params:SeparatedTrailing<(<VarDeclKeyword> <Ident>), ",">> ")"
        _TimeStackEnter <code:FuncBodyOrSemicolon> _TimeStackPop
        => Item::Func { inline: inline.is_some(), keyword, name, params, code },

    "script" <number:Sp<LitIntSigned>?> <name:Sp<Ident>> _TimeStackEnter <code:Block> _TimeStackPop
        => Item::AnmScript { number, name, code },

    <keyword:Sp<MetaKeyword>> <name:Sp<Ident>?> <fields:Sp<MetaBracedFields>>
        => Item::Meta { keyword, name, fields },

    <keyword:FileListKeyword> "{" <files:(<LitString> ";")*> "}"
        => Item::FileList { keyword, files },
};

FuncKeyword: FuncKeyword = {
    "int" => FuncKeyword::Type(FuncReturnType::Int),
    "float" => FuncKeyword::Type(FuncReturnType::Float),
    "void" => FuncKeyword::Type(FuncReturnType::Void),
    "sub" => FuncKeyword::Sub,
    "timeline" => FuncKeyword::Timeline,
};

FuncBodyOrSemicolon: Option<Block> = {
    ";" => None,
    <code:Block> => Some(code),
};

FileListKeyword: FileListKeyword = {
    "anim" => FileListKeyword::Anim,
    "ecli" => FileListKeyword::Ecli,
};

MetaKeyword: MetaKeyword = {
    "entry" => MetaKeyword::Entry,
    "meta" => MetaKeyword::Meta,
};

// NOTE: Working with state in LALRPOP is tricky as there are no midrules like bison.
//
// When working with state, you should generally prefer these non-inline versions, as the actions
// will intuitively take place at the location they appear in the grammar.
_TimeStackEnter: () = _TimeStackEnterInline;
_TimeStackPop: () = _TimeStackPopInline;
_TimeGet: i32 = _TimeGetInline;

// Sometimes, unfortunately, the above rules lead to parsing ambiguities and you may need to
// resort to these inline versions.
//
// The inline versions are only executed after the whole rule has been parsed. Thus, you should only
// ever use them at the END OF A RULE; this may require breaking a rule in half.
#[inline] _TimeStackEnterInline: () = => { state.time_stack.push(0); };
#[inline] _TimeStackPopInline: () = => { state.time_stack.pop(); };
#[inline] _TimeGetInline: i32 = => *state.time_stack.last().unwrap();

// ==================================================
// Metadata in a JSON-ish format, used by ANM

Meta: Meta = {
    <x:LitIntSigned> => Meta::Int(x),
    <x:LitFloatSigned> => Meta::Float(x),
    <x:LitString> => Meta::String(x.string),
    <x:Sp<MetaBracedFields>> => Meta::Object(x),
    <name:Sp<Ident>> ":"? <fields:Sp<MetaBracedFields>> => Meta::Variant { name, fields },
    "[" <items:SeparatedTrailing<Sp<Meta>, ",">> "]" => Meta::Array(items),
};

MetaBracedFields: meta::Fields = {
    "{" <kvs:SeparatedTrailing<(<Sp<Ident>> ":" <Sp<Meta>>), ",">> "}" =>? {
        let mut map = indexmap::IndexMap::with_capacity(kvs.len());
        for (key, value) in kvs {
            if let Some(_) = map.insert(key, value) {
                return Err(ParseError::User {
                    error: "metadata contains duplicate key", // TODO: show key
                });
            }
        }
        Ok(map)
    },
};

// ==================================================
// Statements

Stmt: Stmt = {
    <stuff:StmtLabelsWithTime> <body:Sp<StmtBody>> => {
        let (labels, time) = stuff;
        Stmt { time, labels, body }
    },
};

StmtBody: StmtBody = {
    "return" <value:Sp<Expr>?> ";" => StmtBody::Return { value },
    <chain: CondChain> => StmtBody::CondChain(chain),
    <keyword:Sp<CondKeyword>> "(" <cond:Sp<Cond>> ")" <jump:StmtGoto> ";" => StmtBody::CondJump { keyword, cond, jump },
    "do" <block:StmtOrBlock> "while" "(" <cond:Sp<Cond>> ")" ";" => StmtBody::While { is_do_while: true, cond, block },
    "while" "(" <cond:Sp<Cond>> ")" <block:StmtOrBlock> => StmtBody::While { is_do_while: false, cond, block },
    "times" "(" <count:Sp<Expr>> ")" <block:StmtOrBlock> => StmtBody::Times { count, block },
    "loop" <block:StmtOrBlock> => StmtBody::Loop { block },
    <jump:StmtGoto> ";" => StmtBody::Jump(jump),
    <e:Sp<Expr>> ";" => StmtBody::Expr(e),
    "interrupt" "[" <arg:Sp<LitIntSigned>> "]" ":" => StmtBody::InterruptLabel(arg),
    <var:Sp<Var>> <op:Sp<OpAssign>> <value:Sp<Expr>> ";" => StmtBody::Assignment { var, op, value },
    <keyword:Sp<VarDeclKeyword>> <vars:SeparatedStrict<Sp<StmtDeclarationListItem>, ",">> ";" => {
        StmtBody::Declaration { keyword, vars }
    },
    StmtSpecialCall,
}

StmtTimeLabel: () = {
    "+" <dt:LitIntUnsigned> ":" => { *state.time_stack.last_mut().expect("empty time stack?! (bug)") += dt; },
    <t:LitIntSigned> ":" => { *state.time_stack.last_mut().expect("empty time stack?! (bug)") = t; },
};

/// Read all statement labels and then get the time at the end of them.
///
/// This exists because it is obscenely difficult to make unambiguous while getting the time read correctly.
/// (though in retrospect, it does kind of make sense that the parser would have to speculatively check the
///  time after every label it parses)
StmtLabelsWithTime: (Vec<Sp<StmtLabel>>, i32) = {
    <time: _TimeGetInline> => (vec![], time),
    <out:StmtLabels> StmtTimeLabel <time: _TimeGetInline> => (out, time),
    <out:StmtLabels> <label:Sp<StmtLabel>> <time: _TimeGetInline> => (push(out, label), time),
};

#[inline]
StmtLabels: Vec<Sp<StmtLabel>> = <out:StmtLabelsWithTime> => out.0;

StmtLabel: StmtLabel = {
    <name:Sp<Ident>> ":" => StmtLabel::Label(name),
    <flags:DifficultyLabel> => StmtLabel::Difficulty { flags, temporary: false },
    <flags:DifficultyLabel> ":" => StmtLabel::Difficulty { flags, temporary: true },
};

StmtGoto: StmtGoto = {
    "goto" <destination:Sp<Ident>> <time:("@" <LitIntSigned>)?> => StmtGoto { destination, time },
};

StmtSpecialCall: StmtBody = {
    // handle cases where at least one of the '@' or 'async' are present
    "@" <call_parts:ExprCallParts> <async_:CallAsyncKind?> ";" => {
        let (func, args) = call_parts;
        StmtBody::CallSub { at_symbol: true, func, args, async_ }
    },
    <call_parts:ExprCallParts> <async_:CallAsyncKind> ";" => {
        let (func, args) = call_parts;
        StmtBody::CallSub { at_symbol: true, func, args, async_: Some(async_) }
    },
};

CallAsyncKind: ast::CallAsyncKind = {
    "async" => ast::CallAsyncKind::CallAsync,
    "async" <id:Box<Sp<Expr>>> => ast::CallAsyncKind::CallAsyncId(id),
};

StmtDeclarationListItem: (Sp<Var>, Option<Sp<Expr>>) = {
    <var:Sp<VarIdent>> => (var, None),
    <var:Sp<VarIdent>> "=" <value:Sp<Expr>> => (var, Some(value)),
};

CondChain: ast::StmtCondChain = {
    <chain:CondChainWithoutElse> => chain,
    <mut chain:CondChainWithoutElse> "else" <else_block:StmtOrBlock> => {
        assert!(chain.else_block.is_none());
        chain.else_block = Some(else_block);
        chain
    },
};
CondChainWithoutElse: ast::StmtCondChain = {
    <cond_block:CondBlock> => {
        ast::StmtCondChain { cond_blocks: vec![cond_block], else_block: None }
    },
    <mut chain:CondChainWithoutElse> "else" <cond_block:CondBlock> => {
        chain.cond_blocks.push(cond_block);
        chain
    },
};

CondBlock: CondBlock = {
    <kind:CondKeyword> "(" <cond:Sp<Cond>> ")" <block:StmtOrBlock> => CondBlock { keyword:kind, cond, block },
};

Cond: Cond = {
    <var:Sp<Var>> "--" => Cond::Decrement(var),
    <expr:Sp<Expr>> => Cond::Expr(expr),
};

// block for an 'if', 'while', etc.
StmtOrBlock: Block = {
    // FIXME: Todo: single statement.  (creates ambiguous grammar, how to fix?)
//    <st:Stmt> => vec![st],
    Block,
};

CondKeyword: CondKeyword = {
    "if" => CondKeyword::If,
//    "unless" => CondKeyword::Unless,
};

DifficultyLabel: DifficultyLabel = {
    // TODO: Actually parse
    <s:DIFFICULTY> => s["!".len()..].to_owned(),
};

Block: Block = {
    "{" <start_span:Span> <start_time:_TimeGet> <mut code:Sp<Stmt>*>
        <end_labels:Sp<StmtLabels>> <end_time:_TimeGet> <end_span:Span> "}"
        => {
        // add a special "end of block" statement
        code.insert(0, Sp {
            span: start_span,
            value: Stmt {
                time: start_time,
                labels: vec![],
                body: Sp { span: start_span, value: StmtBody::NoInstruction },
            },
        });
        code.push(Sp {
            span: end_labels.span,
            value: Stmt {
                time: end_time,
                labels: end_labels.value,
                body: Sp { span: end_span, value: StmtBody::NoInstruction },
            },
        });
        Block(code)
    },
};

// ==================================================
// Expressions

// Precedence is encoded in the use of these macros
RightTernary<NextTier>: Expr = {
    <cond:Box<Sp<NextTier>>>
        "?" <left:Box<Sp<NextTier>>>
        ":" <right:Box<Sp<RightTernary<NextTier>>>>
        => Expr::Ternary { cond, left, right },
    NextTier,
};
LeftBinop<Op, NextTier>: Expr = {
    <a:Box<Sp<LeftBinop<Op, NextTier>>>>
        <op:Sp<Op>>
        <b:Box<Sp<NextTier>>>
        => Expr::Binop(a, op, b),
    NextTier,
};
LeftUnop<Op, NextTier>: Expr = {
    // no recursion; only allow one unary op
    <op:Sp<Op>> <e:Box<Sp<NextTier>>> => Expr::Unop(op, e),
    NextTier,
};

Expr: Expr = ExprWithOpers;

// Operator precedence table
ExprWithOpers = ExprTernary;
ExprTernary = RightTernary<ExprBinopOr>;
ExprBinopOr = LeftBinop<OpOr, ExprBinopAnd>;
ExprBinopAnd = LeftBinop<OpAnd, ExprBinopBitOr>;
ExprBinopBitOr = LeftBinop<OpBitOr, ExprBinopBitXor>;
ExprBinopBitXor = LeftBinop<OpBitXor, ExprBinopBitAnd>;
ExprBinopBitAnd = LeftBinop<OpBitAnd, ExprBinopCmpEq>;
ExprBinopCmpEq = LeftBinop<OpCmpEq, ExprBinopCmpOrd>;
ExprBinopCmpOrd = LeftBinop<OpCmpOrd, ExprBinopAddLike>;
ExprBinopAddLike = LeftBinop<OpAddLike, ExprBinopMulLike>;
ExprBinopMulLike = LeftBinop<OpMulLike, ExprUnop>;
ExprUnop = LeftUnop<OpLeftUnary, ExprTerm>;

OpOr: BinopKind = "||" => BinopKind::LogicOr;
OpAnd: BinopKind = "&&" => BinopKind::LogicAnd;
OpBitOr: BinopKind = "|" => BinopKind::BitOr;
OpBitXor: BinopKind = "^" => BinopKind::BitXor;
OpBitAnd: BinopKind = "&" => BinopKind::BitAnd;
OpCmpEq: BinopKind = {
    "==" => BinopKind::Eq,
    "!=" => BinopKind::Ne,
};
OpCmpOrd: BinopKind = {
    ">" => BinopKind::Gt,
    "<" => BinopKind::Lt,
    ">=" => BinopKind::Ge,
    "<=" => BinopKind::Le,
};
OpAddLike: BinopKind = {
    "+" => BinopKind::Add,
    "-" => BinopKind::Sub,
};
OpMulLike: BinopKind = {
    "*" => BinopKind::Mul,
    "/" => BinopKind::Div,
    "%" => BinopKind::Rem,
};
OpAssign: AssignOpKind = {
    "=" => AssignOpKind::Assign,
    "+=" => AssignOpKind::Add,
    "-=" => AssignOpKind::Sub,
    "*=" => AssignOpKind::Mul,
    "/=" => AssignOpKind::Div,
    "%=" => AssignOpKind::Rem,
    "|=" => AssignOpKind::BitOr,
    "^=" => AssignOpKind::BitXor,
    "&=" => AssignOpKind::BitAnd,
};
#[inline] OpLeftUnary: UnopKind = {
    "-" => UnopKind::Neg,
    "!" => UnopKind::Not,
};

FuncUnopKeyword: UnopKind = {
	"sin" => UnopKind::Sin,
	"cos" => UnopKind::Cos,
	"sqrt" => UnopKind::Sqrt,
	"_S" => UnopKind::CastI,
	"_f" => UnopKind::CastF,
};

// Expressions that don't contain a toplevel operator
ExprTerm: Expr = {
    "(" <e:Expr> ")" => e,
    <op:Sp<FuncUnopKeyword>> "(" <e:Box<Sp<Expr>>> ")" => Expr::Unop(op, e),
    <call_parts:ExprCallParts> => {
        let (func, args) = call_parts;
        Expr::Call { func, args }
    },
    <v:Sp<Var>> => Expr::Var(v),
    <value:LitIntUnsigned> => Expr::LitInt { value, hex: false },
    <value:LitFloatUnsigned> => Expr::LitFloat { value },
    <x:LitString> => Expr::LitString(x),

    // This syntax is reserved.
    // The only reason we parse it right now is just to prove that adding it wouldn't make the grammar ambiguous.
    <Var> "[" <Expr> "]" =>? Err(ParseError::User { error: "array indexing is not a thing, sorry" }),
};

ExprCallParts: (Sp<Ident>, Vec<Sp<Expr>>) = {
    <Sp<Ident>> "(" <SeparatedTrailing<Sp<Expr>, ",">> ")",
};

// ==================================================

LitString: LitString = {
    <s:STRING> =>? {
        let mut out = vec![];
        let mut escape = false;
        for b in s[1..s.len()-1].bytes() { // FIXME input should be &[u8] instead of &str
            if escape {
                escape = false;
                match b {
                    b'0' => out.push(b'\0'),
                    b'"' => out.push(b'"'),
                    b'\\' => out.push(b'\\'),
                    b'n' => out.push(b'\n'),
                    b'r' => out.push(b'\r'),
                    _ => return Err(ParseError::User {
                        error: "invalid escape",
                    }),
                }
            } else {
                out.push(b);
            }
        }
        Ok(LitString { string: out.into() })
    },
};

LitFloatSigned: f32 = {
    "-" <x:LitFloatUnsigned> => -x,
    <x:LitFloatUnsigned> => x,
};

LitIntSigned: i32 = {
    "-" <x:LitIntUnsigned> => i32::wrapping_neg(x),
    <x:LitIntUnsigned> => x,
};

LitFloatUnsigned: f32 = {
    <mut s:FLOAT> => {
        if s.ends_with(b"f") || s.ends_with(b"F") {
            s = &s[..s.len()-1];
        }
        parse_ascii(s).unwrap()
    },
    <mut s:FLOAT_RAD> => {
        s = &s[b"rad(".len()..];
        s = &s[..s.len()-b")".len()];
        if s.ends_with(b"f") || s.ends_with(b"F") {
            s = &s[..s.len()-1];
        }
        parse_ascii::<_, f32>(s).unwrap().to_radians()
    },
};

LitIntUnsigned: i32 = {
    // FIXME: Don't panic on big numbers
    <s:INT> => parse_ascii(s).unwrap(),
    <s:INT_HEX> => u32_from_ascii_radix(&s[2..], 16).unwrap() as i32,
    <s:INT_BIN> => u32_from_ascii_radix(&s[2..], 2).unwrap() as i32,
    "true" => 1,
    "false" => 0,
};

// ==================================================
// Variables

Var: Var = {
    VarIdent,
    "$" <ident:Ident> => Var::Named { ty_sigil: Some(VarReadType::Int), ident },
    "%" <ident:Ident> => Var::Named { ty_sigil: Some(VarReadType::Float), ident },
    "[" <sign:OptionalMinus> <x:LitIntUnsigned> "]" =>? {
        Ok(Var::Resolved { ty_sigil: Some(VarReadType::Int), var_id: VarId::Reg(i32::wrapping_mul(x, sign)) })
    },
    "[" <sign:OptionalMinus> <x:LitFloatUnsigned> "]" =>? {
        if x < i32::min_value() as f32 || x > i32::max_value() as f32 {
            return Err(ParseError::User { error: "variable ID overflow" })
        }
        let reg = i32::wrapping_mul(x as i32, sign);
        if reg as f32 != x * sign as f32 {
            return Err(ParseError::User { error: "non-integer variable ID" })
        }
        Ok(Var::Resolved { ty_sigil: Some(VarReadType::Float), var_id: VarId::Reg(reg) })
    },
};

VarIdent: Var = <ident:Ident> => Var::Named { ty_sigil: None, ident };

VarDeclKeyword: VarDeclKeyword = {
    "int" => VarDeclKeyword::Int,
    "float" => VarDeclKeyword::Float,
    "var" => VarDeclKeyword::Var,
};

OptionalMinus: i32 = {
    "-" => -1,
    => 1,
};

Ident: Ident = {
    <tok:IdentStr> =>? {
        std::str::from_utf8(&tok[..]).expect("cannot fail because lexed token is ascii")
            .parse()
            // FIXME: user error should include error message from .parse()
            .map_err(|_| ParseError::User { error: "illegal identifier" })
    },
};

IdentStr: &'input BStr = {
    // obviously
    IDENT,
    // contextual keywords
    <s: "mapfile"> => s.as_static_bstr().unwrap(),
    <s: "entry"> => s.as_static_bstr().unwrap(),
    <s: "anim"> => s.as_static_bstr().unwrap(),
    <s: "ecli"> => s.as_static_bstr().unwrap(),
    <s: "timeline"> => s.as_static_bstr().unwrap(),
    <s: "script"> => s.as_static_bstr().unwrap(),
};

// ==================================================
// Utility

/// Parse something while obtaining its span.
#[inline]
Sp<Rule>: Sp<Rule> = {
    <l: @L> <rule: Rule> <r: @R> => Sp {
        span: crate::pos::Span::new(state.file_id, l, r),
        value: rule,
    },
}
/// Get a zero-length span at the current position.
Span: crate::pos::Span = <sp:Sp<()>> => sp.span;

Box<Rule>: Box<Rule> = <r:Rule> => Box::new(r);

/// Parse a separated sequence with an optional trailing separator.
SeparatedTrailing<T, Sep>: Vec<T> = {
    => vec![],
    <SeparatedStrictNonempty<T, Sep>>,
    <SeparatedStrictNonempty<T, Sep>> Sep,
};

/// Parse a separated sequence with no trailing separator.
SeparatedStrict<T, Sep>: Vec<T> = {
    => vec![],
    <SeparatedStrictNonempty<T, Sep>>,
};
SeparatedStrictNonempty<T, Sep>: Vec<T> = {
    <x:T> => vec![x],
    <mut xs:SeparatedStrictNonempty<T, Sep>> Sep <x:T> => {
        xs.push(x);
        xs
    },
};
